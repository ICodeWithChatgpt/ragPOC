<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Prompt Page</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
<div class="container">
    <div class="content">
        <h1>Content Processor</h1>
        <form id="content-form">
            <div class="form-group">
                <label for="input-data">Enter a URL or paste raw content below:</label>
                <textarea id="input-data" placeholder="URL / RAW Text" name="input-data"></textarea>
            </div>
            <button type="button" class="btn" onclick="fetchContent()">Fetch Content</button>
            <div class="form-group">
                <label for="edited-content">Edit the content below:</label>
                <textarea id="edited-content" placeholder="Final content comes here..." name="edited-content"></textarea>
            </div>
            <div class="form-group">
                <label for="chunk-size">Chunk Size:</label>
                <input type="number" id="chunk-size" value="250">
                <span class="info-icon" id="info-icon">ℹ️</span>
                <div class="info-dialog" id="info-dialog">
                    <p><strong>Chunk Size Recommendations:</strong></p>
                    <p>Choose the appropriate chunk size based on the content length and the type of analysis:</p>
                    <ul>
                        <li><strong>Small Content (Less than 1,000 words):</strong>
                            <br>Use a chunk size of <strong>100–200 tokens</strong>.
                            <br><em>Why? Ensures finer granularity, ideal for detailed patterns in short texts.</em>
                        </li>
                        <li><strong>Medium Content (1,000–5,000 words):</strong>
                            <br>Use a chunk size of <strong>200–500 tokens</strong>.
                            <br><em>Why? Balances granularity and processing efficiency for medium texts.</em>
                        </li>
                        <li><strong>Large Content (More than 5,000 words):</strong>
                            <br>Use a chunk size of <strong>500–1,000 tokens</strong>.
                            <br><em>Why? Larger chunks reduce splits while preserving detail for long content.</em>
                        </li>
                        <li><strong>Specific Analysis:</strong>
                            <br>Use a chunk size of <strong>100–200 tokens</strong>.
                            <br><em>Why? Best for extracting precise themes or sentiments.</em>
                        </li>
                        <li><strong>Broader Analysis:</strong>
                            <br>Use a chunk size of <strong>500–1,000 tokens</strong>.
                            <br><em>Why? Ideal for summarization and high-level overviews.</em>
                        </li>
                    </ul>
                </div>
            </div>
            <button type="button" class="btn" onclick="processContent()">Process Content</button>
        </form>
        <div id="result"></div>
    </div>
    <div class="content">
        <h1>Prompt Interface</h1>
        <form id="promptForm">
            <div class="form-group">
                <label for="prompt">Ask the model:</label>
                <textarea id="prompt" placeholder="Enter your prompt here..." name="prompt"></textarea>
            </div>
            <div class="form-group">
            <input type="checkbox" id="searchDB" name="searchDB">
            <label for="searchDB" style="display: inline;">Search DB first</label>
            </div>
            <br>
            <div class="form-group" >
                <label for="metadata-similarity">Metadata Similarity Threshold:</label>
                <span id="metadata-similarity-value">0.80</span>
                <input type="range" id="metadata-similarity" name="metadata-similarity" min="0" max="1" step="0.01" value="0.80" disabled>
            </div>
            <div class="form-group">
                <label for="vectorized-similarity">Vectorized Similarity Threshold:</label>
                <span id="vectorized-similarity-value">0.80</span>
                <input type="range" id="vectorized-similarity" name="vectorized-similarity" min="0" max="1" step="0.01" value="0.80" disabled>
            </div>
            <button type="button" class="btn" onclick="submitPrompt()">Submit</button>
        </form>
        <div id="loading" style="display: none;">
            <div class="spinner"></div>
        </div>

        <h2>User's Initial Prompt</h2>
        <textarea id="initialPrompt" readonly></textarea>
        <h2>Augmented Prompt</h2>
        <textarea id="finalPrompt" readonly></textarea>
        <h2>Response from the LLM</h2>
        <textarea id="response" readonly></textarea>
    </div>
</div>
<script src="{{ url_for('static', filename='script.js') }}"></script>
</body>
</html>
<script>
    // JavaScript functions remain the same
    document.getElementById('metadata-similarity').addEventListener('input', function() {
        document.getElementById('metadata-similarity-value').innerText = this.value;
    });

    document.getElementById('vectorized-similarity').addEventListener('input', function() {
        document.getElementById('vectorized-similarity-value').innerText = this.value;
    });

    document.getElementById('chunk-size').addEventListener('input', function() {
    const chunkSize = parseInt(this.value);
    console.log(`Chunk size changed to: ${chunkSize}`);
    });

    document.getElementById('info-icon').addEventListener('mouseover', function() {
    document.getElementById('info-dialog').style.display = 'block';
});

document.getElementById('info-icon').addEventListener('mouseout', function() {
    document.getElementById('info-dialog').style.display = 'none';
});


    document.getElementById('searchDB').addEventListener('change', function() {
        const isChecked = this.checked;
        document.getElementById('metadata-similarity').disabled = !isChecked;
        document.getElementById('vectorized-similarity').disabled = !isChecked;
    });

    // Initialize the sliders based on the initial state of the checkbox
    window.onload = function() {
        const isChecked = document.getElementById('searchDB').checked;
        document.getElementById('metadata-similarity').disabled = !isChecked;
        document.getElementById('vectorized-similarity').disabled = !isChecked;
    };

    function submitPrompt() {
    const prompt = document.getElementById('prompt').value.trim();
    const metadataSimilarity = parseFloat(document.getElementById('metadata-similarity').value);
    const vectorizedSimilarity = parseFloat(document.getElementById('vectorized-similarity').value);
    const searchDB = document.getElementById('searchDB').checked;

    const loadingDiv = document.getElementById('loading');
    loadingDiv.style.display = "block"; // Show spinner

    fetch('/prompt', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            prompt: prompt,
            searchDB: searchDB,
            metadata_similarity: metadataSimilarity,
            vectorized_similarity: vectorizedSimilarity
        }),
    })
    .then(response => response.json())
    .then(data => {
        document.getElementById('initialPrompt').value = data.initial_prompt || "N/A";
        document.getElementById('finalPrompt').value = data.final_prompt || "N/A";
        document.getElementById('response').value = data.response || "No response.";
    })
    .catch(error => {
        console.error('Error handling prompt:', error);
        document.getElementById('response').value = "An error occurred.";
    })
    .finally(() => {
        loadingDiv.style.display = "none"; // Hide spinner after completion
    });
}

    document.getElementById("promptForm").addEventListener("submit", async function (e) {
        e.preventDefault();

        const prompt = document.getElementById("prompt").value;
        const searchDB = document.getElementById("searchDB").checked;

        const loadingDiv = document.getElementById("loading");
        loadingDiv.style.display = "block";

        const formData = new FormData();
        formData.append("prompt", prompt);
        formData.append("searchDB", searchDB);

        try {
            const response = await fetch("/prompt", {
                method: "POST",
                body: formData
            });
            const result = await response.json();

            document.getElementById("initialPrompt").innerText = result.initial_prompt || "N/A";
            document.getElementById("finalPrompt").innerText = result.final_prompt || "N/A";
            document.getElementById("response").innerText = result.response || "No response.";

        } catch (err) {
            console.error("Error:", err);
            document.getElementById("response").innerText = "An error occurred.";
        } finally {
            loadingDiv.style.display = "none";
        }
    });
    function fetchContent() {
        const inputData = document.getElementById('input-data').value.trim();
        fetch('/fetch-content', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ input_data: inputData }),
        })
        .then(response => response.json())
        .then(data => {
            document.getElementById('edited-content').value = data.raw_content;
        })
        .catch(error => console.error('Error fetching content:', error));
    }

    function processContent() {
        const editedContent = document.getElementById('edited-content').value.trim();
        const metadataSimilarity = parseFloat(document.getElementById('metadata-similarity').value);
        const vectorizedSimilarity = parseFloat(document.getElementById('vectorized-similarity').value);
        const chunkSize = parseInt(document.getElementById('chunk-size').value);
        console.log("Chunk size from frontend:", chunkSize);

        fetch('/process-content', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                edited_content: editedContent,
                metadata_similarity: metadataSimilarity,
                vectorized_similarity: vectorizedSimilarity,
                chunk_size: chunkSize
            }),
        })
        .then(response => response.json())
        .then(data => {
            document.getElementById('result').innerText = JSON.stringify(data, null, 2);
        })
        .catch(error => console.error('Error processing content:', error));
    }
    function updateResults(data) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';

        if (data && data.length > 0) {
            data.forEach(item => {
                const resultDiv = document.createElement('div');
                resultDiv.classList.add('result');

                const tagsDiv = document.createElement('p');
                tagsDiv.textContent = `Tags: ${item.tags}`;

                const summaryDiv = document.createElement('p');
                summaryDiv.textContent = `Summary: ${item.summary}`;

                const scoreDiv = document.createElement('p');
                scoreDiv.textContent = `Similarity Score: ${item.similarity.toFixed(3)}`;

                resultDiv.appendChild(tagsDiv);
                resultDiv.appendChild(summaryDiv);
                resultDiv.appendChild(scoreDiv);

                resultsDiv.appendChild(resultDiv);
            });
        } else {
            resultsDiv.innerHTML = '<p>No relevant content found.</p>';
        }
    }
</script>
